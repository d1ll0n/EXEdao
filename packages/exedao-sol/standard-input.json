{
  "language": "Solidity",
  "sources": {
    "ExeDAO.sol": {
      "content": "pragma solidity ^0.5.5;\npragma experimental ABIEncoderV2;\n\nimport \"./Extendable.sol\";\nimport \"./storage/ExeDAOStorage.sol\";\nimport \"./interfaces/IExeDAO.sol\";\n\ncontract ExeDAO is IExeDAO, Extendable, ExeDAOStorage {\n  event ApplicationAdded(address applicant, uint64 shares);\n  event ApplicationCanceled(address applicant);\n\n  constructor(\n    uint64 shares, uint64 _proposalDuration,\n    bytes4[] memory funcSigs, uint8[] memory requirements\n  ) public payable Extendable(shares, _proposalDuration, funcSigs, requirements) {}\n\n  function setMinimumTribute(uint256 minimum) external {\n    if (_voteAndContinue()) _minimumTribute = minimum;\n  }\n\n  function safeExecute(bytes calldata bytecode) external {\n    require(bytecode.isPermissible(), \"ExeDAO: Bytecode not allowed\");\n    if (_voteAndContinue()) bytecode.delegateExecute();\n  }\n\n  /**\n   * @dev Apply to join the DAO and lock some wei/tokens.\n   */\n  function submitApplication(bytes32 metaHash, uint64 shares, DaoLib.TokenValue[] calldata tokenTributes) external payable {\n    require(!_daoistIndices[msg.sender].exists, \"ExeDAO: Already a daoist\");\n    Indices.Index memory index = _applicationIndices[msg.sender];\n    require(!index.exists, \"ExeDAO: Application pending\");\n    require(shares > 0 && msg.value >= _minimumTribute, \"ExeDAO: Bad application\");\n    uint256 tokenCount = tokenTributes.length;\n    address[] memory lockedTokens = new address[](tokenCount);\n    uint256[] memory lockedTokenValues = new uint256[](tokenCount);\n    for (uint256 i = 0; i < tokenCount; i++) {\n      DaoLib.TokenValue memory tokenTribute = tokenTributes[i];\n      _receiveToken(tokenTribute.tokenAddress, msg.sender, tokenTribute.value);\n      lockedTokens[i] = tokenTribute.tokenAddress;\n      lockedTokenValues[i] = tokenTribute.value;\n    }\n    DaoLib.Application memory application = DaoLib.Application(metaHash, msg.value, msg.sender, lockedTokens, lockedTokenValues, shares);\n    index = Indices.Index(true, uint248(_applications.length));\n    _applicationIndices[msg.sender] = index;\n    _applications.push(application);\n    emit ApplicationAdded(msg.sender, shares);\n  }\n\n  /**\n   * @dev For buyer, cancel the offer and reclaim wei if a proposal has not been\n   * started by a daoist or has expired. For daoists, vote to accept the offer.\n   */\n  function executeApplication(address applicant) external {\n    Indices.Index memory index = _applicationIndices[applicant];\n    require(index.exists, \"ExeDAO: Application not found\");\n    DaoLib.Application memory application = _applications[index.index];\n    if (msg.sender == applicant) {\n      Indices.Index memory proposalIndex = _proposalIndices[keccak256(msg.data)];\n      if (proposalIndex.exists) {\n        require(\n          block.number >= _proposals[index.index].expiryBlock,\n          \"ExeDAO: Must wait for proposal to finish\"\n        );\n        if (index.index > _lastExpiredApplication.index) _lastExpiredApplication = index;\n      }\n      delete _applications[index.index];\n      delete _applicationIndices[applicant];\n      emit ApplicationCanceled(applicant);\n      msg.sender.transfer(application.weiTribute);\n      for (uint256 i = 0; i < application.tokenTributes.length; i++) {\n        _transferToken(application.tokenTributes[i], msg.sender, application.tokenTributeValues[i]);\n      }\n    }\n    else if (_voteAndContinue()) {\n      delete _applications[index.index];\n      delete _applicationIndices[applicant];\n      _mintShares(applicant, application.shares);\n    }\n  }\n}"
    },
    "Extendable.sol": {
      "contents": "pragma solidity ^0.5.5;\npragma experimental ABIEncoderV2;\n\nimport \"./lib/ExeLib.sol\";\nimport \"./Permissioned.sol\";\nimport \"./storage/ExtendableStorage.sol\";\nimport \"./interfaces/IExtendable.sol\";\n\ncontract Extendable is IExtendable, Permissioned, ExtendableStorage {\n  event ExtensionAdded(uint256 extensionIndex, bytes32 metaHash);\n\n  constructor(\n    uint64 shares, uint64 _proposalDuration,\n    bytes4[] memory funcSigs, uint8[] memory requirements\n  ) public payable Permissioned(shares, _proposalDuration, funcSigs, requirements) {}\n\n  function () external payable {\n    Indices.Index memory index = _extensionFor[msg.sig];\n    if (index.exists) {\n      if (_voteAndContinue()) {\n        ExeLib.Extension memory extension = _extensions[index.index];\n        if (extension.useDelegate) extension.extensionAddress.delegateExecute();\n        else extension.extensionAddress.doCall();\n      }\n    }\n  }\n\n  function removeExtension(uint256 extIndex) external {\n    if (_voteAndContinue()) {\n      ExeLib.Extension memory ext = _extensions[extIndex];\n      for (uint256 i = 0; i < ext.functionSignatures.length; i++) {\n        bytes4 funcSig = ext.functionSignatures[i];\n        delete _extensionFor[funcSig];\n        if (_approvalRequirements[funcSig] != 0) delete _approvalRequirements[funcSig];\n      }\n      delete _extensions[extIndex];\n    }\n  }\n\n  function addExtension(ExeLib.Extension memory extension) public {\n    if (extension.useDelegate) require(\n      extension.bytecode.length > 0 && extension.bytecode.isPermissible(),\n      \"ExeDAO: Bytecode not allowed\"\n    );\n    if (_voteAndContinue()) {\n      if (extension.useDelegate) {\n        extension.extensionAddress = extension.bytecode.deploy();\n        delete extension.bytecode;\n      }\n      uint256 index = _extensions.length;\n      _extensions.push(extension);\n      bytes4[] memory funcSigs = extension.functionSignatures;\n      for (uint256 i = 0; i < funcSigs.length; i++) {\n        require(!_extensionFor[funcSigs[i]].exists, \"ExeDAO: Approval already set\");\n        _extensionFor[funcSigs[i]] = Indices.Index(true, uint248(index));\n      }\n      emit ExtensionAdded(index, extension.metaHash);\n    }\n  }\n}\n"
    },
    "storage/ExeDAOStorage.sol": {
      "contents": "pragma solidity ^0.5.5;\npragma experimental ABIEncoderV2;\n\nimport \"../lib/DaoLib.sol\";\nimport \"../lib/Indices.sol\";\n\ncontract ExeDAOStorage {\n  uint256 internal _minimumTribute;\n  Indices.Index internal _lastExpiredApplication;\n  DaoLib.Application[] internal _applications;\n  mapping(address => Indices.Index) internal _applicationIndices;\n\n  function getMinimumTribute() external view returns (uint256 minimum) {\n    minimum = _minimumTribute;\n  }\n\n  function getApplication(address applicant) external view\n  returns (DaoLib.Application memory application) {\n    Indices.Index memory index = _applicationIndices[applicant];\n    require(index.exists, \"ExeDAO: Application not found\");\n    return _applications[index.index];\n  }\n\n  function getOpenApplications() external view\n  returns (DaoLib.Application[] memory applications) {\n    Indices.Index memory lastExpired = _lastExpiredApplication;\n    uint256 startIndex = lastExpired.exists ? lastExpired.index + 1 : 0;\n    uint256 size = _applications.length - startIndex;\n    applications = new DaoLib.Application[](size);\n    for (uint256 i = 0; i < size; i++) {\n      uint256 index = startIndex + i;\n      applications[i] = _applications[index];\n    }\n  }\n}"
    },
    "interfaces/IExeDAO.sol": {
      "contents": "pragma solidity ^0.5.5;\npragma experimental ABIEncoderV2;\n\nimport \"../lib/DaoLib.sol\";\nimport \"./IExtendable.sol\";\n\ncontract IExeDAO is IExtendable {\n  function getApplication(address applicant) external view returns (DaoLib.Application memory application);\n  function getOpenApplications() external view returns (DaoLib.Application[] memory applications);\n  function getMinimumTribute() external view returns (uint256 minimum);\n  function setMinimumTribute(uint256 minimum) external;\n  function safeExecute(bytes calldata bytecode) external;\n  function submitApplication(bytes32 metaHash, uint64 shares, DaoLib.TokenValue[] calldata tokenTributes) external payable;\n  function executeApplication(address applicant) external;\n}"
    },
    "lib/ExeLib.sol": {
      "contents": "pragma solidity ^0.5.5;\n\nlibrary ExeLib {\n  struct Extension {\n    bytes32 metaHash; // used to share abi and function descriptions\n    address extensionAddress;\n    bool useDelegate;\n    bytes bytecode;\n    bytes4[] functionSignatures;\n  }\n\n  function isPermissible (bytes memory bytecode)\n  internal pure returns (bool) {\n    uint256 size = bytecode.length;\n    uint256 permissible = 1;\n    assembly {\n      let ptr := add(bytecode, 0x20)\n      for { let i := 0 } and(lt(i, size), permissible) { i := add(i, 0x1) } {\n        let op := shr(0xf8, mload(add(ptr, i)))\n        switch op\n        case 0xf2 { permissible := 0 } // callcode\n        case 0xf4 { permissible := 0 } // delegatecall\n        case 0x55 { permissible := 0 } // sstore\n        case 0xff { permissible := 0 } // selfdestruct\n        default {\n          let isPush := and(lt(op, 0x80), gt(op, 0x5f))\n          if eq(isPush, 0x1) { i := add(i, sub(op, 0x5f)) }\n        }\n      }\n    }\n    return permissible == 1;\n  }\n\n  function deploy(bytes memory bytecode) internal returns (address extAddress) {\n    uint256 size = bytecode.length;\n    assembly {\n      let start := add(bytecode, 0x20)\n      extAddress := create(0, start, size)\n    }\n  }\n\n  function delegateExecute(bytes memory bytecode) internal {\n    uint256 size = bytecode.length;\n    assembly {\n      let retptr := mload(0x40)\n      let start := add(bytecode, 0x20)\n      let delegateTo := create(0, start, size)\n      if iszero(delegateTo) {\n        returndatacopy(retptr, 0, returndatasize)\n        revert(retptr, returndatasize)\n      }\n      let delegateSuccess := delegatecall(gas, delegateTo, 0, 0, retptr, 0)\n      returndatacopy(retptr, 0, returndatasize)\n      if iszero(delegateSuccess) { revert(retptr, returndatasize) }\n      return (retptr, returndatasize)\n    }\n  }\n\n  function delegateExecute(address delegateTo) internal {\n    assembly {\n      let startCalldata := mload(0x40)\n      calldatacopy(startCalldata, 0, calldatasize)\n      let retptr := add(startCalldata, calldatasize)\n      let delegateSuccess := delegatecall(gas, delegateTo, startCalldata, calldatasize, retptr, 0)\n      returndatacopy(retptr, 0, returndatasize)\n      if delegateSuccess { return (retptr, returndatasize) }\n      revert(retptr, returndatasize)\n    }\n  }\n\n  function doCall(address callAddress) internal {\n    assembly {\n      let startCalldata := mload(0x40)\n      calldatacopy(startCalldata, 0, calldatasize)\n      let retptr := add(startCalldata, calldatasize)\n      let callSuccess := call(gas, callAddress, callvalue, startCalldata, calldatasize, retptr, 0)\n      returndatacopy(retptr, 0, returndatasize)\n      if callSuccess { return (retptr, returndatasize) }\n      revert(retptr, returndatasize)\n    }\n  }\n}\n"
    },
    "Permissioned.sol": {
      "contents": "pragma solidity ^0.5.5;\npragma experimental ABIEncoderV2;\n\nimport \"./BaseDAO.sol\";\n// import \"./lib/SignatureUnpack.sol\";\nimport \"./storage/PermissionedStorage.sol\";\nimport \"./interfaces/IPermissioned.sol\";\n\n/**\n * @title Permissioned\n * @notice Generic contract for creating, cancelling and processing _proposals to execute functions.\n * @dev Approval requirements are set per function signature.\n */\ncontract Permissioned is IPermissioned, BaseDAO, PermissionedStorage {\n  // using SignatureUnpack for bytes;\n\n  event ProposalSubmission(address indexed submitter, bytes32 indexed proposalHash, bytes32 metaHash, uint64 votesCast);\n  event ProposalVote(address indexed voter, bytes32 indexed proposalHash, uint64 votesCast);\n  event ProposalApproval(address indexed voter, bytes32 indexed proposalHash);\n  event ProposalExpiration(bytes32 indexed proposalHash);\n\n  constructor(\n    uint64 shares, uint64 proposalDuration,\n    bytes4[] memory funcSigs, uint8[] memory requirements\n  ) public payable BaseDAO(shares) {\n    require(funcSigs.length == requirements.length, \"ExeDAO: Bad inputs\");\n    for (uint256 i = 0; i < funcSigs.length; i++) {\n      uint8 approvalRequirement = requirements[i];\n      require(\n        approvalRequirement < 101 || approvalRequirement == 255,\n        \"Can not set empty requirement\"\n      );\n      _approvalRequirements[funcSigs[i]] = approvalRequirement;\n    }\n    _proposalDuration = proposalDuration;\n  }\n\n  function setProposalDuration(uint64 duration) external {\n    if (_voteAndContinue()) _proposalDuration = duration;\n  }\n\n  function mintShares(address recipient, uint64 amount) external {\n    if (_voteAndContinue()) _mintShares(recipient, amount);\n  }\n\n  function addToken(address tokenAddress) external {\n    if (_voteAndContinue()) _addToken(tokenAddress);\n  }\n\n  function removeToken(address tokenAddress) external {\n    if (_voteAndContinue()) _removeToken(tokenAddress);\n  }\n\n  function approveTokenTransfer(address tokenAddress, address spender, uint256 amount) external {\n    if (_voteAndContinue()) _approveTokenTransfer(tokenAddress, spender, amount);\n  }\n\n  function transferToken(address tokenAddress, address recipient, uint256 amount) external {\n    if (_voteAndContinue()) _transferToken(tokenAddress, recipient, amount);\n  }\n\n  function receiveToken(address tokenAddress, address sender, uint256 amount) external {\n    if (_voteAndContinue()) _receiveToken(tokenAddress, sender, amount);\n  }\n\n  function transferEther(address payable recipient, uint256 weiToSend) external {\n    if (_voteAndContinue()) recipient.transfer(weiToSend);\n  }\n\n  /**\n   * @dev Set the requirement for execution of a function.\n   * @param funcSig The signature of the function which approval is being set for.\n   * funcSig can not be the signature for setApprovalRequirement.\n   * @param approvalRequirement Percentage of shares which must be met for an approval to be accepted.\n   * If approvalRequirement is 0, the function can not be called by anyone. If it is 255, it does not require approval.\n   */\n  function setApprovalRequirement(bytes4 funcSig, uint8 approvalRequirement) external {\n    require(funcSig != msg.sig, \"ExeDAO: Can not modify requirement\");\n    require(approvalRequirement < 101 || approvalRequirement == 255, \"ExeDAO: Bad requirement\");\n    if (_voteAndContinue()) _approvalRequirements[funcSig] = approvalRequirement;\n  }\n\n  function submitOrVote(bytes32 proposalHash) external returns(uint, uint) {\n    uint64 shares = _getShares();\n    Indices.Index memory index = _proposalIndices[proposalHash];\n    _submitOrVote(msg.sender, proposalHash, shares, index);\n    Proposals.Proposal memory proposal = _proposals[index.index];\n    return(proposal.votes, proposal.expiryBlock);\n  }\n\n  /**\n   * @notice Create a proposal and set an ipfs hash for finding data about it.\n   * @dev The calldata for a proposal can be uploaded to IPFS with keccak-sha256 as the hash algorithm.\n   * For proposals to execute code or add extensions, it is useful to be able to share the raw code which compiles\n   * to the contract bytecode for easy verification of what is being executed without needing to audit the bytecode.\n   * For private proposals, the IPFS hash could point to ciphertext which only daoists can decrypt via some key exchange.\n   */\n  function submitWithMetaHash(bytes32 proposalHash, bytes32 metaHash) external returns(uint256 index) {\n    uint64 shares = _getShares();\n    Indices.Index memory _index = _proposalIndices[proposalHash];\n    require(!_index.exists, \"ExeDAO: Proposal exists\");\n    index = _index.index;\n    _submitOrVote(msg.sender, proposalHash, shares, _index);\n    _proposalMetaHashes[proposalHash] = metaHash;\n  }\n\n  /** @dev Cancel a proposal if it has expired. */\n  function closeProposal(bytes32 proposalHash) external {\n    Indices.Index memory index = _proposalIndices[proposalHash];\n    Proposals.Proposal memory proposal = _proposals[index.index];\n    if (proposal.expiryBlock <= block.number) {\n      delete _proposals[index.index];\n      delete _proposalIndices[proposalHash];\n      if (_proposalMetaHashes[proposalHash] != 0) delete _proposalMetaHashes[proposalHash];\n      if (index.index > _lastExpiredProposal.index) _lastExpiredProposal = index;\n      emit ProposalExpiration(proposalHash);\n    }\n  }\n\n  /* function supplyOfflineVotesWithCall(\n    bytes calldata wrappedCalldata,\n    bytes[] calldata sigs,\n    uint256[] calldata nonces,\n    bytes32[] calldata proposalHashes\n  ) external returns (bytes memory) {\n    for (uint256 i = 0; i < sigs.length; i++) {\n      address voter = sigs[i].recoverOffline(nonces[i], proposalHashes[i]);\n      require(!_offlineNonces[voter][nonces[i]], \"ExeDAO: Nonce already used\");\n      _offlineNonces[voter][nonces[i]] = true;\n      DaoLib.DaoistOutput memory daoist = getDaoist(voter);\n      require(daoist.shares > 0, \"ExeDAO: Signature supplied from non-daoist\");\n      uint64 shares = daoist.shares;\n      Indices.Index memory index = _proposalIndices[proposalHashes[i]];\n      _submitOrVote(voter, proposalHashes[i], shares, index);\n    }\n    (, bytes memory retval) = address(this).delegatecall(wrappedCalldata);\n    // if this call throws it doesn't matter, allow anyone to pay the gas to submit offline signatures even in the absence of valid calldata\n    return retval;\n  } */\n\n  /**\n   * @dev Call _submitOrVote() and return true if the proposal is approved, false if not.\n   */\n  function _voteAndContinue() internal returns (bool) {\n    bytes32 proposalHash = keccak256(msg.data);\n    (uint64 shares, Indices.Index memory index, bool approved) = _preProcessProposal(proposalHash);\n    if (approved) {\n      if (index.exists) {\n        delete _proposals[index.index];\n        delete _proposalIndices[proposalHash];\n        if (_proposalMetaHashes[proposalHash] != 0) delete _proposalMetaHashes[proposalHash];\n      }\n      emit ProposalApproval(msg.sender, proposalHash);\n    } else _submitOrVote(msg.sender, proposalHash, shares, index);\n    return approved;\n  }\n\n  /**\n   * @dev Determines whether a proposal would be accepted given the caller's votes.\n   */\n  function _preProcessProposal(bytes32 proposalHash) internal view\n  returns (uint64 shares, Indices.Index memory index, bool approved) {\n    uint8 approvalRequirement = _approvalRequirements[msg.sig];\n    index = _proposalIndices[proposalHash];\n    if (approvalRequirement == 255) return (0, index, true);\n    shares = _getShares();\n    uint64 totalNeeded = Proposals.votesRemaining(_totalShares, 0, approvalRequirement);\n    if (!index.exists) approved = shares >= totalNeeded;\n    else {\n      uint64 votes = _proposals[index.index].votes;\n      if (votes >= totalNeeded) approved = true;\n      else approved = shares >= (totalNeeded - votes);\n    }\n  }\n\n  /**\n   * @dev Create a proposal if it does not exist, vote on it otherwise.\n   */\n  function _submitOrVote(address voter, bytes32 proposalHash, uint64 shares, Indices.Index memory index) internal {\n    if (!index.exists) {\n      Indices.Index memory _index = Indices.Index(true, uint248(_proposals.length));\n      _proposalIndices[proposalHash] = _index;\n      _proposals.push(Proposals.Proposal(proposalHash, shares, uint64(block.number + _proposalDuration)));\n      _proposals[_index.index].voters[voter] = true;\n      emit ProposalSubmission(voter, proposalHash, _proposalMetaHashes[proposalHash], shares);\n    } else {\n      Proposals.Proposal storage proposal = _proposals[index.index];\n      require(proposal.expiryBlock > block.number, \"ExeDAO: Proposal expired\");\n      if (!proposal.voters[voter]) {\n        proposal.voters[voter] = true;\n        proposal.votes = uint64(proposal.votes.add(shares));\n        emit ProposalVote(voter, proposalHash, shares);\n      }\n    }\n  }\n}\n"
    },
    "storage/ExtendableStorage.sol": {
      "contents": "pragma solidity ^0.5.5;\npragma experimental ABIEncoderV2;\n\nimport \"../lib/ExeLib.sol\";\nimport \"../lib/Indices.sol\";\n\n/**\n * @title ExtendableStorage\n * @author Dillon Kellar, Raymond Pulver\n * @dev Storage and getters for Extendable.sol\n * @notice Makes the contract less cluttered by separating getters and storage setup into a separate contract.\n */\ncontract ExtendableStorage {\n  using ExeLib for address;\n  using ExeLib for bytes;\n\n  ExeLib.Extension[] internal _extensions;\n  mapping(bytes4 => Indices.Index) internal _extensionFor;\n\n  function getExtension(uint256 index) external view returns (ExeLib.Extension memory) {\n    return _extensions[index];\n  }\n\n  function getExtensions() external view\n  returns (ExeLib.Extension[] memory) { return _extensions; }\n\n  function getExtensionFor(bytes4 funcSig) external view\n  returns (ExeLib.Extension memory extension) {\n    Indices.Index memory index = _extensionFor[funcSig];\n    require(index.exists, \"ExeDAO: Extension not found\");\n    return _extensions[index.index];\n  }\n}"
    },
    "interfaces/IExtendable.sol": {
      "contents": "pragma solidity ^0.5.5;\npragma experimental ABIEncoderV2;\n\nimport \"../lib/ExeLib.sol\";\nimport \"./IPermissioned.sol\";\n\ncontract IExtendable is IPermissioned {\n  function getExtension(uint256 index) external view returns (ExeLib.Extension memory);\n  function getExtensionFor(bytes4 funcSig) external view returns (ExeLib.Extension memory extension);\n  function getExtensions() external view returns (ExeLib.Extension[] memory);\n  function removeExtension(uint256 extIndex) external;\n  function addExtension(ExeLib.Extension memory extension) public;\n}"
    },
    "lib/DaoLib.sol": {
      "contents": "pragma solidity ^0.5.5;\n\nlibrary DaoLib {\n  struct Daoist {\n    address daoist;\n    uint64 shares;\n  }\n\n  struct DaoistOutput {\n    address daoist;\n    uint64 shares;\n    uint248 index;\n  }\n\n  struct TokenValue {\n    address tokenAddress;\n    uint256 value;\n  }\n\n  struct Application {\n    bytes32 metaHash;\n    uint256 weiTribute;\n    address applicant;\n    address[] tokenTributes;\n    uint256[] tokenTributeValues;\n    uint64 shares;\n  }\n}"
    },
    "lib/Indices.sol": {
      "contents": "pragma solidity ^0.5.5;\n\nlibrary Indices {\n  struct Index {\n    bool exists;\n    uint248 index;\n  }\n}"
    },
    "BaseDAO.sol": {
      "contents": "pragma solidity ^0.5.5;\npragma experimental ABIEncoderV2;\n\nimport \"./storage/BaseDAOStorage.sol\";\nimport \"./interfaces/IBaseDAO.sol\";\n\n/**\n * @title BaseDAO\n * @author Dillon Kellar, Raymond Pulver\n * @notice Keeps track of who owns shares in a DAO and provides a method for burning shares in exchange for ether owned by the contract.\n * @dev Does not expose any external methods for giving shares, must be handled by child\n */\ncontract BaseDAO is IBaseDAO, BaseDAOStorage {\n  event SharesBurned(address indexed daoist, uint64 shares);\n  event SharesMinted(address indexed daoist, uint64 shares);\n  event TokenAdded(address indexed tokenAddress);\n  event TokenRemoved(address indexed tokenAddress);\n  event TokenTransferred(address indexed tokenAddress, address indexed recipient, uint256 amount);\n  event TokenReceived(address indexed tokenAddress, address indexed sender, uint256 amount);\n\n\n  constructor(uint64 shares) public payable {\n    _mintShares(msg.sender, shares);\n  }\n\n  /**\n   * @dev Returns the number of shares owned by the sender. Reverts if the user has no shares.\n   */\n  function _getShares() internal view returns (uint64 shares) {\n    shares = getDaoist(msg.sender).shares;\n    require(shares > 0, \"ExeDAO: Not a daoist\");\n  }\n\n  function burnShares(uint64 amount) external\n  returns(uint256 weiValue, DaoLib.TokenValue[] memory tokenBurnValues) {\n    DaoLib.DaoistOutput memory _daoist = getDaoist(msg.sender);\n    require(_daoist.shares >= amount, \"ExeDAO: Not enough shares\");\n    // use large multiplier to avoid rounding errors\n    uint256 relativeShare = _multiplier.mul(amount).div(_totalShares);\n    // subtract shares prior to sending anything to prevent reentrance\n    _daoists[_daoist.index].shares = uint64(_daoist.shares.sub(amount));\n    _totalShares = uint64(_totalShares.sub(amount));\n    uint256 numTokens = _tokens.length;\n    tokenBurnValues = new DaoLib.TokenValue[](numTokens);\n    uint256 shareValue;\n    uint256 balance;\n    for (uint256 i = 0; i < numTokens; i++) {\n      IERC20 token = _tokens[i];\n      balance = token.balanceOf(address(this));\n      shareValue = relativeShare.mul(balance).div(_multiplier);\n      token.transfer(msg.sender, shareValue);\n      tokenBurnValues[i] = DaoLib.TokenValue(address(token), shareValue);\n    }\n    weiValue = address(this).balance.mul(relativeShare).div(_multiplier);\n    msg.sender.transfer(weiValue);\n    emit SharesBurned(msg.sender, amount);\n  }\n\n  function _mintShares(address recipient, uint64 amount) internal {\n    Indices.Index memory index = _daoistIndices[recipient];\n    if (!index.exists) {\n      _daoistIndices[recipient] = Indices.Index(true, uint248(_daoists.length));\n      _daoists.push(DaoLib.Daoist(recipient, amount));\n    } else {\n      _daoists[index.index].shares = uint64(_daoists[index.index].shares.add(amount));\n    }\n    _totalShares = uint64(_totalShares.add(amount));\n    emit SharesMinted(recipient, amount);\n  }\n\n  function _addToken(address tokenAddress) internal {\n    Indices.Index memory index = _tokenIndices[tokenAddress];\n    require(!index.exists, \"ExeDAO: Token exists\");\n    _tokenIndices[tokenAddress] = Indices.Index(true, uint248(_tokens.length));\n    _tokens.push(IERC20(tokenAddress));\n    emit TokenAdded(tokenAddress);\n  }\n\n  function _removeToken(address tokenAddress) internal {\n    Indices.Index memory index = _tokenIndices[tokenAddress];\n    require(index.exists, \"ExeDAO: Token not found\");\n    delete _tokenIndices[tokenAddress];\n    delete _tokens[index.index];\n    emit TokenRemoved(tokenAddress);\n  }\n\n  function _approveTokenTransfer(address tokenAddress, address spender, uint256 amount) internal {\n    IERC20 token = _getToken(tokenAddress);\n    require(token.approve(spender, amount), \"ExeDAO: Approve transfer failed\");\n  }\n\n  function _receiveToken(address tokenAddress, address sender, uint256 amount) internal {\n    IERC20 token = _getToken(tokenAddress);\n    require(token.transferFrom(sender, address(this), amount), \"ExeDAO: transferFrom failed.\");\n    emit TokenReceived(tokenAddress, sender, amount);\n  }\n\n  function _transferToken(address tokenAddress, address recipient, uint256 amount) internal {\n    IERC20 token = _getToken(tokenAddress);\n    require(token.transfer(recipient, amount), \"ExeDAO: Transfer failed\");\n    emit TokenTransferred(tokenAddress, recipient, amount);\n  }\n}"
    },
    "storage/PermissionedStorage.sol": {
      "contents": "pragma solidity ^0.5.5;\npragma experimental ABIEncoderV2;\n\nimport \"../lib/Proposals.sol\";\nimport \"../lib/Indices.sol\";\n\n/**\n * @title PermissionedStorage\n * @author Dillon Kellar, Raymond Pulver\n * @dev Storage and getters for Permissioned.sol\n * @notice Makes the contract less cluttered by separating getters and storage setup into a separate contract.\n */\ncontract PermissionedStorage {\n  uint64 internal _proposalDuration;\n  Indices.Index internal _lastExpiredProposal;\n  Proposals.Proposal[] internal _proposals;\n  mapping(bytes32 => Indices.Index) internal _proposalIndices;\n  mapping(bytes4 => uint8) internal _approvalRequirements;\n  mapping(bytes32 => bytes32) internal _proposalMetaHashes;\n  mapping(address => mapping(uint256 => bool)) internal _nonces;\n\n  function nextNonce(address daoist) external view returns (uint256 nonce) {\n    nonce = 0;\n    while(true) {\n      if (!_nonces[daoist][nonce]) break;\n      else nonce += 1;\n    }\n    return nonce;\n  }\n\n  function getApprovalRequirement(bytes4 funcSig) external view returns (uint8 requirement) {\n    requirement = _approvalRequirements[funcSig];\n  }\n\n  function getApprovalRequirements(bytes4[] calldata funcSigs) external view\n  returns (uint8[] memory requirements) {\n    uint256 size = funcSigs.length;\n    requirements = new uint8[](size);\n    for (uint256 i = 0; i < size; i++) requirements[i] = _approvalRequirements[funcSigs[i]];\n  }\n\n  /** @dev allows clients to retrieve index and proposal data in one call */\n  function getProposal(bytes32 proposalHash) external view\n  returns (Proposals.ProposalOutput memory ret) {\n    Indices.Index memory index = _proposalIndices[proposalHash];\n    require(index.exists, \"ExeDAO: Proposal not found\");\n    Proposals.Proposal memory proposal = _proposals[index.index];\n    ret = Proposals.ProposalOutput(\n      proposalHash, _proposalMetaHashes[proposalHash],\n      proposal.votes, proposal.expiryBlock, index.index\n    );\n  }\n\n  function getOpenProposals() external view\n  returns (Proposals.ProposalOutput[] memory proposals) {\n    Indices.Index memory lastExpired = _lastExpiredProposal;\n    uint256 startIndex = lastExpired.exists ? lastExpired.index + 1 : 0;\n    uint256 size = _proposals.length - startIndex;\n    proposals = new Proposals.ProposalOutput[](size);\n    for (uint256 i = 0; i < size; i++) {\n      uint256 index = startIndex + i;\n      Proposals.Proposal memory proposal = _proposals[index];\n      bytes32 proposalHash = proposal.proposalHash;\n      proposals[i] = Proposals.ProposalOutput(\n        proposalHash, _proposalMetaHashes[proposalHash],\n        proposal.votes, proposal.expiryBlock, index\n      );\n    }\n  }\n\n  function getProposalMetaHash(bytes32 proposalHash)\n  external view returns(bytes32 metaHash) {\n    return _proposalMetaHashes[proposalHash];\n  }\n}"
    },
    "interfaces/IPermissioned.sol": {
      "contents": "pragma solidity ^0.5.5;\npragma experimental ABIEncoderV2;\n\nimport \"../lib/Proposals.sol\";\nimport \"./IBaseDAO.sol\";\n\ncontract IPermissioned is IBaseDAO {\n  function transferEther(address payable recipient, uint256 weiToSend) external;\n  function getApprovalRequirement(bytes4 funcSig) external view returns (uint8 requirement);\n  function getApprovalRequirements(bytes4[] calldata funcSigs) external view returns (uint8[] memory requirements);\n  function getOpenProposals() external view returns (Proposals.ProposalOutput[] memory proposals);\n  function getProposal(bytes32 proposalHash) external view returns (Proposals.ProposalOutput memory ret);\n  function setProposalDuration(uint64 duration) external;\n  function mintShares(address recipient, uint64 amount) external;\n  function setApprovalRequirement(bytes4 funcSig, uint8 approvalRequirement) external;\n  function submitOrVote(bytes32 proposalHash) external returns(uint, uint);\n  function submitWithMetaHash(bytes32 proposalHash, bytes32 metaHash) external returns(uint256 index);\n  function closeProposal(bytes32 proposalHash) external;\n  /* function supplyOfflineVotesWithCall(\n    bytes calldata wrappedCalldata,\n    bytes[] calldata sigs,\n    uint256[] calldata nonces,\n    bytes32[] calldata proposalHashes\n  ) external returns (bytes memory); */\n  function addToken(address tokenAddress) external;\n  function removeToken(address tokenAddress) external;\n  function approveTokenTransfer(address tokenAddress, address spender, uint256 amount) external;\n  function transferToken(address tokenAddress, address recipient, uint256 amount) external;\n  function receiveToken(address tokenAddress, address sender, uint256 amount) external;\n}"
    },
    "storage/BaseDAOStorage.sol": {
      "contents": "pragma solidity ^0.5.5;\npragma experimental ABIEncoderV2;\n\nimport \"../lib/SafeMath.sol\";\nimport \"../lib/IERC20.sol\";\nimport \"../lib/DaoLib.sol\";\nimport \"../lib/Indices.sol\";\n\n/**\n * @title BaseDAOStorage\n * @author Dillon Kellar, Raymond Pulver\n * @dev Storage and getters for BaseDao.sol\n * @notice Makes the contract less cluttered by separating getters and storage setup into a separate contract.\n */\ncontract BaseDAOStorage {\n  using SafeMath for uint64;\n  using SafeMath for uint256;\n\n  uint256 internal _multiplier = 2 finney;\n  uint64 internal _totalShares;\n  DaoLib.Daoist[] internal _daoists;\n  mapping(address => Indices.Index) internal _daoistIndices;\n  IERC20[] internal _tokens;\n  mapping(address => Indices.Index) internal _tokenIndices;\n\n  function getTotalShares() external view returns (uint64 totalShares) {\n    totalShares = _totalShares;\n  }\n\n  function getDaoist(address daoistAddress) public view returns (DaoLib.DaoistOutput memory daoist) {\n    Indices.Index memory index = _daoistIndices[daoistAddress];\n    require(index.exists, \"ExeDAO: Daoist not found\");\n    DaoLib.Daoist memory _daoist = _daoists[index.index];\n    daoist = DaoLib.DaoistOutput(_daoist.daoist, _daoist.shares, index.index);\n  }\n\n  function getDaoists() external view returns (DaoLib.Daoist[] memory daoists) {\n    uint256 size = _daoists.length;\n    daoists = new DaoLib.Daoist[](size);\n    for (uint256 i = 0; i < size; i++) daoists[i] = _daoists[i];\n  }\n\n  function getToken(address tokenAddress) external view returns (DaoLib.TokenValue memory tokenValue) {\n    IERC20 _token = _getToken(tokenAddress);\n    uint256 balance = _token.balanceOf(address(this));\n    tokenValue = DaoLib.TokenValue(address(_token), balance);\n  }\n\n  function getTokens() external view returns (DaoLib.TokenValue[] memory tokenBalances) {\n    uint256 size = _tokens.length;\n    tokenBalances = new DaoLib.TokenValue[](size);\n    for (uint256 i = 0; i < size; i++) {\n      uint256 balance = _tokens[i].balanceOf(address(this));\n      tokenBalances[i] = DaoLib.TokenValue(address(_tokens[i]), balance);\n    }\n  }\n\n  function _getToken(address tokenAddress) internal view returns (IERC20 token) {\n    Indices.Index memory index = _tokenIndices[tokenAddress];\n    require(index.exists, \"ExeDAO: Token not found\");\n    token = _tokens[index.index];\n  }\n}"
    },
    "interfaces/IBaseDAO.sol": {
      "contents": "pragma solidity ^0.5.5;\npragma experimental ABIEncoderV2;\n\nimport \"../lib/DaoLib.sol\";\n\ninterface IBaseDAO {\n  function getDaoist(address daoistAddress) external view returns (DaoLib.DaoistOutput memory daoist);\n  function getDaoists() external view returns (DaoLib.Daoist[] memory daoists);\n  function getToken(address tokenAddress) external view returns (DaoLib.TokenValue memory token);\n  function getTokens() external view returns (DaoLib.TokenValue[] memory tokens);\n  function burnShares(uint64 amount) external returns(uint256 weiValue, DaoLib.TokenValue[] memory tokenBurnValues);\n}"
    },
    "lib/Proposals.sol": {
      "contents": "pragma solidity ^0.5.5;\n\nlibrary Proposals {\n  struct Proposal {\n    bytes32 proposalHash;\n    uint64 votes;\n    uint64 expiryBlock;\n    mapping(address => bool) voters;\n  }\n\n  struct ProposalOutput {\n    bytes32 proposalHash;\n    bytes32 metaHash;\n    uint64 votes;\n    uint64 expiryBlock;\n    uint256 proposalIndex;\n  }\n\n  function votesRemaining (uint64 totalShares, uint64 votes, uint8 approvalRequirement)\n  internal pure returns (uint64) {\n    uint64 totalNeeded = totalShares * approvalRequirement / 100;\n    if (votes >= totalNeeded) return 0;\n    else return totalNeeded - votes;\n  }\n}"
    },
    "lib/SafeMath.sol": {
      "contents": "pragma solidity ^0.5.5;\n\n/**\n * @title SafeMath\n * @dev Unsigned math operations with safety checks that revert on error\n*/\nlibrary SafeMath {\n  /**\n  * @dev Multiplies two unsigned integers, reverts on overflow.\n  */\n  function mul(uint a, uint b) internal pure returns (uint) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) return 0;\n    uint c = a * b;\n    require(c / a == b, \"SM: mul error\");\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n  */\n  function div(uint a, uint b) internal pure returns (uint) {\n    // Solidity only automatically asserts when dividing by 0\n    require(b > 0, \"SM: div error\");\n    uint c = a / b;\n    return c;\n  }\n\n  /**\n  * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint a, uint b) internal pure returns (uint) {\n    require(b <= a, \"SM: sub error\");\n    uint c = a - b;\n    return c;\n  }\n\n  /**\n  * @dev Adds two unsigned integers, reverts on overflow.\n  */\n  function add(uint a, uint b) internal pure returns (uint) {\n    uint c = a + b;\n    require(c >= a, \"SM: add error\");\n    return c;\n  }\n\n  /**\n  * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n  * reverts when dividing by zero.\n  */\n  function mod(uint a, uint b) internal pure returns (uint) {\n    require(b != 0);\n    return a % b;\n  }\n}"
    },
    "lib/IERC20.sol": {
      "contents": "pragma solidity ^0.5.5;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * > Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n"
    }
  },
  "settings": {
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode"
        ]
      }
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    }
  }
}